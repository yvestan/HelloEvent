/**
 *  Zebra_Form
 *
 *  Client-side validation for Zebra_Form
 *
 *  Visit {@link http://stefangabos.ro/php-libraries/zebra-form/} for more information.
 *
 *  For more resources visit {@link http://stefangabos.ro/}
 *
 *  @author     Stefan Gabos <contact@stefangabos.ro>
 *  @version    2.6.1 (last revision: July 01, 2011)
 *  @copyright  (c) 2011 Stefan Gabos
 *  @license    http://www.gnu.org/licenses/lgpl-3.0.txt GNU LESSER GENERAL PUBLIC LICENSE
 *  @package    Zebra_DatePicker
 */
(function($) {

    $.Zebra_Form = function(element, options) {

        var plugin = this;

        // public properties
        var defaults = {
            scroll_to_error: true,
            tips_position: 'left',
            close_tips: true,
            process_path: null
        }

        plugin.settings = {}

        // private properties
        var validation_rules = new Object,
            controls_groups = new Object,
            placeholders = new Object,
            error_blocks = new Object,
            reload = false;

        // the jQuery version of the element
        // "form" (without the $) will point to the DOM element
        var $form = $(element),
            form = element;

        // code by Joyce Babu
        // found at http://www.weberdev.com/get_example-4437.html
        plugin.filter_input = function(filter_type, evt, custom_chars) {
            var key_code, key, control, filter = '';
            var alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
            var digits = '0123456789';
            if (window.event) {
                key_code = window.event.keyCode;
                evt = window.event;
            } else if (evt)
                key_code = evt.which;
            else
                return true;
            switch (filter_type) {
                case 'alphabet':
                    filter = alphabet;
                    break;
                case 'digits':
                case 'number':
                case 'float':
                    filter = digits;
                    break;
                case 'alphanumeric':
                    filter = alphabet + digits;
                    break;
                default:
                    return true;
            }
            if (custom_chars) { filter += custom_chars }
            control = evt.srcElement ? evt.srcElement : evt.target || evt.currentTarget;
            if (key_code==null || key_code==0 || key_code==8 || key_code==9 || key_code==13 || key_code==27) return true;
            key = String.fromCharCode(key_code);
            if (filter.indexOf(key) > -1) return true;
            if (filter_type == 'number' && key == '-' && _get_caret_position(control) == 0) return true;
            if (filter_type == 'float' && ((key == '-' && _get_caret_position(control) == 0) || (key == '.' && _get_caret_position(control) != 0 && control.value.match(/\./) == null))) return true;
            return false;
        }

        /**
         *  Constructor method
         *
         *  @return void
         */
        plugin.init = function() {

            plugin.settings = $.extend({}, defaults, options);

            // find all dummy options and remove them from the DOM
            // we need them"dummy options" to create valid HTML/XHTML output because empty option groups are not
            // allowed; unfortunately, IE does not support neither the "disabled" attribute nor styling these
            // empty options so we need to remove them from the DOM
            $form.find('option.dummy').remove();

            // find any error blocks generated by the server-side script and iterate through them
            $form.find('div.error').each(function() {

                var error_block = $(this);

                // get a reference to the "close" button on the error block
                var close_button = error_block.first('div.close>a');

                // onclick, morph the error block's height and opacity to 0
                close_button.click(function(e) {

                    e.preventDefault();

                    error_block.animate({
                        'height'    : 0,
                        'opacity'   : 0
                    },
                    250,
                    function() {

                        // remove from DOM
                        error_block.remove();

                    });

                });

            });

            // get all the form's elements
            var elements = $form.find('.control');

            // iterate through the form's elements
            elements.each(function() {

                var element = $(this);

                // get the ID of the element
                var attributes = {'id': element.attr('id'), 'type': _type(element)};

                // highlight the row that the element is in
                // get the element's parent element that has the "row" class set
                var parent = element.closest('.row');

                // if there is such an element
                // (jQuery returns an empty array if no parent could be found, thus an array with length 0)
                if (parent.length) {

                    // bind these events to the element
                    element.bind({

                        // when the element receives focus
                        // add the "highlight" class to the parent element
                        'focus': function() { parent.addClass('highlight') },

                        // when the element receives focus
                        // remove the "highlight" class from the parent element
                        'blur': function() { parent.removeClass('highlight') }

                    });

                }

                if (

                    // if element has the "inner-label" class set
                    // meaning that the element's label needs to be shown inside the element until the element has focus
                    element.hasClass('inner-label') && (

                        // the class is applied to an allowed element type
                        attributes['type'] == 'text' ||
                        attributes['type'] == 'password' ||
                        attributes['type'] == 'textarea'

                    )

                ) {

                    // extend "attributes" with some new entries
                    attributes = $.extend(attributes, {'class': element.attr('class')}, {'style': element.attr('style')}, {'alt': element.attr('alt')});

                    // we need to create a "dummy" text element that will replace the original element until the "dummy"
                    // element receives the focus; the "dummy" element will "clone" the original element's ID, class and
                    // style
                    var placeholder = jQuery('<input type="text">').attr({
                        'id':       attributes['id'],
                        'class':    $.trim(attributes['class'].replace(/validate\[.*\]/, '').replace(/inner\-label/, '')) + ' placeholder',
                        'style':    attributes['style'],
                        'value':    attributes['alt']
                    }).css({
                        display:    'none'
                    });

                    // cache the placeholder element
                    placeholders[attributes['id']] = placeholder;

                    // when the placeholder receives focus
                    placeholder.focus(function() {

                        // hide the error message if it is visible
                        plugin.hide_error(element.attr('name').replace(/\[\]$/, ''));

                        // hide the placeholder
                        placeholder.css('display', 'none');

                        // show the original element
                        element.css('display', element.hasClass('inline') ? 'inline' : 'block');

                        // set focus to the original element
                        element.focus();

                    });

                    // when the element loses focus
                    element.blur(function() {

                        // if no value was entered
                        if (element.val() == '') {

                            // hide the original element
                            element.css('display', 'none');

                            // show the corresponding placeholder
                            placeholders[element.attr('id')].css('display', element.hasClass('inline') ? 'inline' : 'block');

                        }

                    });

                    // by default, if element has no value
                    if (element.val() == '') {

                        // show the placeholder
                        placeholder.css('display', element.hasClass('inline') ? 'inline' : 'block');

                        // and hide the original element
                        element.css('display', 'none');

                    // if element has a default value, show the original element
                    } else element.css('display', element.hasClass('inline') ? 'inline' : 'block');

                    // inject the placeholder into the DOM, right after the original element
                    element.after(placeholder);

                // if element has the "other" class set and element is a drop-down
                } else if (element.hasClass('other') && attributes['type'] == 'select-one') {

                    // run this private method that shows/hides the "other" text box depending on the selection
                    _show_hide_other_option(element);

                    // whenever the drop-down's value is changed
                    element.change(function() {

                        // run this private method that shows/hides the "other" text box depending on the selection
                        _show_hide_other_option(element);

                    });

                }

                // if there are any validation rules set for this element
                if (undefined != plugin.settings.error_messages && undefined != typeof plugin.settings.error_messages[attributes['id']]) {

                    // register the element
                    plugin.register(element, false);

                }

            });

            // attach a function to the form's "submit" event
            $form.bind('submit', function(e) {

                // if
                if (

                    // form is not to be simply reloaded
                    reload == false &&

                    // and there are any controls that need to be validated
                    undefined != plugin.settings.error_messages

                ) {

                    // if not all controls validate
                    if (!plugin.validate()) {

                        // prevent the form from being submitted
                        // we check for the existence of "e" because the form can also be submitted by calling the
                        // submit() method, case in which "e" is not available
                        if (undefined != e) e.preventDefault();

                        // show the appropriate error message
                        plugin.show_errors();

                    // if form validates but was submitted by calling the object's submit() method
                    // we check for the existence of "e" because the form can also be submitted by calling the
                    // submit() method, case in which "e" is not available
                    } else if (undefined == e)

                        // submit the form
                        $form.submit();

                }

            });

        }

        /**
         *  Shows an error tooltip, with a custom message, for a given element.
         *
         *  @param  string  element     The name (id) of a form's element to attach the tip to.
         *
         *  @param  string  message     The message to be displayed in the tooltip.
         *
         *  @return void
         */
        plugin.attach_tip = function(element, message) {

    		// get element's ID
            var id = $('#' + element).attr('id');

    		// set the message
            validation_rules[id].message = message;

    		// show the error message
            plugin.show_errors(element);

        }

        /**
         *  Hides all error tooltips.
         *
         *  @return void
         */
        plugin.clear_errors = function() {

            // remove all iFrameShims (if available) from the DOM
            $('.Zebra_Form_error_iFrameShim').remove();

            // remove all error messages from the DOM
            $('.Zebra_Form_error_message').remove();

            // remove all error blocks
            error_blocks = [];

        }

        /**
         *  After a file upload occurs, the script will automaticall run this method that removes the temporarily created
         *  iFrame element, the spinner and replaces the file upload control with the name of the uploaded file.
         *
         *  @param  object  element     The jQuery file upload element
         *
         *  @param  array   file_info   An array of properties of the uploaded file, returned by process.php
         *
         *  @return void
         *
         *  @access private
         */
        plugin.end_file_upload = function(element, file_info) {

            var $element = $('#' + element);

            // if element exists
            if ($element.length) {

                // delete the "target" attribute of the form
                $form.removeAttr('target');

                // get the element's ID
                var id = $element.attr('id');

                // remove from the DOM the attached IFrame
                $('#' + id + '_iframe').remove();

                // remove from the DOM the attached spinner
                $('#' + id + '_spinner').remove();

                // if element has rules attached to it
                if (undefined != validation_rules[element]) {

                    // if
                    if (

                        // the method has a second argument
                        undefined != file_info &&

                        // the second argument is an object
                        'object' == typeof(file_info) &&

                        // the second argument is properly formatted
                        undefined != file_info[0] &&
                        undefined != file_info[1] &&
                        undefined != file_info[2] &&
                        undefined != file_info[3]

                    ) {

                        // set the second argument as a property of the element
                        $element.data('file_info', file_info);

                    }

                    // if control does not validate
                    if (true !== plugin.validate_control($element)) {

                        // clear the element's value
                        $element.val('');

                        // make the element visible (was hidden to show the spinner)
                        $element.css('visibility', 'visible');

                        // show the attached error message
                        plugin.show_errors($element);

                    // if control validates
                    } else {

                        // get the element's coordinates, relative to the form
                        var coordinates = $element.position($form);

                        // create a span control containing the file's name
                        // which will replace the file upload control
                        var file_name = jQuery('<span>', {
                            'class':    'filename',
                            css: {
                                'left': coordinates.left,
                                'top': coordinates.top,
                                'width': $element.outerWidth
                            }
                        });

                        // set the file's name as the content of the <span>
                        file_name.html(file_info[0]);

                        // add also an "close" button for canceling file upload
                        var anchor = jQuery('<a>', {
                            'href': 'javascript:void(0)'
                        });

                        anchor.html('x');

                        anchor.click(function(e) {

                            // stop default event
                            e.preventDefault();

                            // remove the uploaded file's name from the DOM
                            file_name.remove();

                            // clear the element's value
                            $element.val('');

                            // if the element has the "file_info" attribute set, remove it
                            if ($element.data('file_info')) $element.removeData('file_info');

                            // make the element visible
                            $element.css('visibility', 'visible');

                        });

                        // inject the "close" button
                        file_name.append(anchor);

                        // inject everything into the DOM
                        $form.append(file_name);

                    }

                }

            }

        }

        /**
         *  Hides the error tooltip for a given element.
         *
         *  @param  string  element_name    The name (id) of a form's element.
         *
         *  @return void
         */
        plugin.hide_error = function(element_name) {

            var container = error_blocks[element_name];

            // if an error block exists for the element with the given id
            if (undefined != container) {

                // fade out the error block
                // (which, on complete, destroys the IFrame shim - if it exists - and also the error block itself)
                container.animate({
                    'opacity'   : 0
                },
                250,
                function() {

                    // get a reference to the iFrame shim (if any)
                    var shim = container.data('shim');

                    // if an attached iFrame shim exists, remove it from the DOM
                    if (undefined != shim) shim.remove();

                    // remove the container from the DOM
                    container.remove()

                    // remove from the error blocks array
                    delete error_blocks[element_name];

                });

            }

        }

        /**
         *  Registers a form element for validation.
         *
         *  @param  object  element A jQuery element.
         *
         *  @return void
         */
        plugin.register = function(element) {

            // get some attributes of the element
            var attributes = {'id': element.attr('id'), 'name': element.attr('name'), 'type': _type(element)};

            // sanitize element's name by removing square brackets (if available)
            attributes['name'] = attributes['name'].replace(/\[\]$/, '');

            switch (attributes['type']) {

                case 'radio':
                case 'checkbox':

                    // attach the function to the onClick and onBlur events
                    element.bind({

                        'click': function() {plugin.hide_error(attributes['name'])},
                        'blur': function() {plugin.hide_error(attributes['name'])}

                    });

                    // we will also keep track of radio buttons and checkboxes sharing the same name
                    if (undefined == controls_groups[attributes['id']]) {

                        // group together radio buttons and checkboxes sharing the same name
                        controls_groups[attributes['id']] = $form.find('input[name^=' + attributes['name'] + ']');

                    }

                    break;

                // if element is file
                case 'file':

                    // we replace the original control with a clone, as only file controls created dynamically from
                    // javascript behave as expected

                    // create a clone of the element (along with content and ID)
                    var clone = element.clone(true);

                    // unset the element's value
                    clone.attr('value', '');

                    // replace the original element
                    element.replaceWith(clone);

                    clone.bind({

                        // attach a function to the onKeyPress event
                        'keypress': function(e) {

                            // stop event
                            e.preventDefault();

                            // unset the element's value
                            clone.attr('value', '');

                        },

                        // attach a function to the onChange event
                        'change': function() {

                            plugin.hide_error(attributes['name']);

                            // if the "file_info" attribute is already set for the element
                            if (clone.data('file_info'))

                                // remove it
                                clone.removeData('file_info');

                            // create an IFrame that we will use to submit the form to
                            var iFrameSubmit = jQuery('<iframe>', {
                                'src':                  'javascript:void(0)',
                                'id':                   attributes['id'] + '_iframe',
                                'name':                 attributes['id'] + '_iframe',
                                'scrolling':            'no',
                                'marginwidth':          0,
                                'marginheight':         0,
                                'width':                0,
                                'height':               0,
                                'frameborder':          0,
                                'allowtransparency':    'true'
                            });

                            // inject the newly created IFrame into the DOM
                            $('body').append(iFrameSubmit);

                            // save the form's original action
                            var original_action = $form.attr('action');

                            // alter the action of the form
                            $form.attr('action',
                                plugin.settings.process_path +
                                '?form=' + $form.attr('id') +
                                '&control=' + attributes['id'] +
                                '&nocache=' + new Date().getTime());

                            // submit the form to the IFrame
                            $form.attr('target', attributes['id'] + '_iframe');

                            // hide the element
                            clone.css('visibility', 'hidden');

                            // get element's coordinates
                            var coordinates = clone.offset();

                            // crate the spinner element
                            // and position it in the same position as the element
                            var spinner = jQuery('<div>', {
                                'id':       attributes['id'] + '_spinner',
                                'class':    'Zebra_Form_spinner',
                                css: {
                                    'left': coordinates.left,
                                    'top':  coordinates.top
                                }
                            });

                            // inject the newly create element into the DOM
                            $('body').append(spinner);

                            reload = true;

                            // submit the form
                            $form.trigger('submit');

                            // restore the form's original action
                            $form.attr('action', original_action);

                            reload = false;

                        // change the scope of "this" so that we can have access to the
                        // Zebra_Form object's properties and methods
                        },

                        // attach a function to the onBlur event
                        'blur': function() {plugin.hide_error(attributes['name'])}

                    });

                    // element will now reference the clone
                    element = clone;

                    break;

                // if element is a select control (single or multi-values)
                case 'select-one':
                case 'select-multiple':

                    // attach the function to the onChange and onBlur events
                    element.bind({

                        'change': function() {plugin.hide_error(attributes['name'])},
                        'blur': function() {plugin.hide_error(attributes['name'])}

                    });

                    break;

                // for all other element types (text, textarea, password)
                default:

                    // attach a function to the onBlur event
                    element.blur(function() {plugin.hide_error(attributes['name'])});

            }

            // get validation rules of the element
            var rules = element.attr('class').match(/validate\[(.+)\]/);

            // if there are any rules
            if (null != rules) {

                // the regular expression used to "split" rules by comma
                var expr = /([^\,]*\(.*?\)|[^\,]+)/g;

                // this will be the list of rules for the current element
                var rules_list = new Object;

                // iterate over the rules
                while (matches = expr.exec(rules[1])) {

                    // extract the rule's name
                    var rule_name = matches[1].match(/^([^\(]+)/);

                    // extract the rule's arguments
                    var rule_arguments = matches[1].match(/\((.*?)\)/)

                    // if there are any arguments to the rule
                    if (rule_arguments) {

                        // split the arguments by commas into an array
                        rule_arguments = rule_arguments[1].split(',');

                        // iterate through the arguments
                        $.each(rule_arguments, function(argument, key) {

                            // replace some special entities set from PHP
                            rule_arguments[argument] = rule_arguments[argument].replace(/lsqb\;/g, '[');
                            rule_arguments[argument] = rule_arguments[argument].replace(/rsqb\;/g, ']');
                            rule_arguments[argument] = rule_arguments[argument].replace(/comma\;/g, ',');
                            rule_arguments[argument] = rule_arguments[argument].replace(/lsb\;/g, '(');
                            rule_arguments[argument] = rule_arguments[argument].replace(/rsb\;/g, ')');

                        });

                    // if there are no arguments to the rule
                    } else {

                        // treat arguments as "null"
                        rule_arguments = null;

                    }

                    // add the rule to the list of rules
                    rules_list[rule_name[1]] = rule_arguments;

                }

                // if a second argument to the method was not provided
                // it means that the script will automatically need to figure out the order in which the element will be
                // validated, based on where it is in the DOM
                if (undefined == arguments[1]) {

                    // get all the form's controls
                    var elements = $form.find('.control');

                    // iterate through the form's controls
                    $.each(elements, function(index, el) {

                        // if we've found the element we're registering
                        if (el == element.get(0)) {

                            var el = $(el);

                            // we need to move backwards and find the previous control in the DOM

                            // the ID of the previous element
                            var previous_element_id = null;

                            // the previous control's position in the validation chain
                            var position = index - 1;

                            // while
                            while (

                                // "previous_element_id" is null
                                previous_element_id == null &&

                                // a previous element exists
                                undefined != elements[position] &&

                                // the previous element doesn't have the "placeholder" class set
                                !$(elements[position]).hasClass('placeholder')

                            ) {

                                // get the ID of the previous element
                                previous_element_id = $(elements[position]).attr('id');

                                // decrement position
                                position--;

                            }

                            // if a previous element doesn't exists
                            if (!validation_rules[previous_element_id]) {

                                // create a temporary object
                                var tmp = new Object;

                                // assign the validation rules
                                tmp[attributes['id']] = {'element': element, 'rules': rules_list};

                                $.extend(validation_rules, tmp);

                            // if a previous element does exist
                            } else {

                                // create a temporary object which will contain the reordered validation rules
                                var new_validation_rules = new Object;

                                // iterate through the already existing validation rules
                                for (index in validation_rules) {

                                    // add each entry to the new array
                                    new_validation_rules[index] = validation_rules[index];

                                    // if we found the previous element
                                    if (previous_element_id == index) {

                                        // append the validation rules for the current element
                                        new_validation_rules[attributes['id']] = {'element': element, 'rules': rules_list};

                                    }

                                }

                                // copy the content of the temporary variable to the validation_rules property
                                validation_rules = new_validation_rules;

                            }

                        }

                    });

                // if a second argument to the method was provided and it is an element
                // it means that the current control needs to be validated after that particular element
                } else if (undefined != arguments[1] && $('#' + arguments[1]).length) {

                    // get the ID of the element after which the current element needs to be validated
                    var id = $('#' + arguments[1]).attr('id');

                    // create a temporary object which will contain the reordered validation rules
                    var new_validation_rules = new Object;

                    // iterate through the already existing validation rules
                    for (index in validation_rules) {

                        // add each entry to the new array
                        new_validation_rules[index] = validation_rules[index];

                        // if we found the previous element
                        if (previous_element_id == index) {

                            // append the validation rules for the current element
                            new_validation_rules[attributes['id']] = {'element': element, 'rules': rules_list};

                        }

                    }

                    // copy the content of the temporary variable to the validation_rules property
                    validation_rules = new_validation_rules;

                // if a second argument to the method was provided and it is boolean false
                // it means that the element will be validated in the same order as it was registered
                } else if (undefined != arguments[1] && arguments[1] === false) {

                    // add the validation rules for the current element
                    validation_rules[attributes['id']] = {'element': element, 'rules': rules_list};

                }

            }

        }

        /**
         *  Shows the error message tooltip for the first control that doesn't validate.
         *
         *  The "validate" or "validate_control" methods needs to be called prior to calling this method or calling
         *  this method will produce no results.
         *
         *  @return void
         */
        plugin.show_errors = function() {

            // hide all existing errors
            plugin.clear_errors();

            var counter = 0;

            // iterate through the validation rules
            for (index in validation_rules) {

                // current validation rule
                var validation_rule = validation_rules[index];

                // current element
                var element = validation_rule['element'];

                // get some attributes of the element
                var attributes = {'id': element.attr('id'), 'name': element.attr('name'), 'type': _type(element)}

                // sanitize element's name by removing square brackets (if available)
                attributes['name'] = attributes['name'].replace(/\[\]$/, '');

                // if the method has an element of the form as argument, and the current element is not that particular
                // element, skip the rest
                if (undefined != arguments[0] && arguments[0].get(0) != element.get(0)) continue;

                // if element's value did not validate (there's an error message)
                if (undefined != validation_rule.message) {

                    // focus the element (IE triggers an error if control has display:none)
                    if (element.css('display') != 'none') element.focus();

                    // if element is hidden (it means that it's placeholder is currently visible)
                    if (element.css('display') == 'none') {

                        // get the placeholder's coordinates
                        var element_position = placeholders[attributes['id']].offset();

                        // find element's "right"
                        element_position = $.extend(element_position, {'right': Math.floor(element_position.left + placeholders[attributes['id']].width())});

                    // if element is visible
                    } else {

                        // get element's coordinates
                        var element_position = $.extend(element.offset());

                        // find element's "right"
                        element_position = $.extend(element_position, {'right': Math.floor(element_position.left + element.width())});

//                             // weird behaviour...
//                             // if an item somewhere far below in a long list of a dropdown is selected, positions get messed up
//                             // get element's scroll
//                             var element_scroll = element.getScroll();
//
//                             // if element is scrolled vertically
//                             if (element_scroll.y != 0) {
//
//                                 // adjust it's top position
//                                 element_position.top += element_scroll.y;
//
//                             }

                    }

                    // the main container holding the error message
                    var container = jQuery('<div/>', {
                        'class':    'Zebra_Form_error_message',
                        css: {
                            opacity: 0
                        }
                    });

                    // the container of the actual error message
                    // width:auto is for IE6
                    var message = jQuery('<div/>', {
                        'class':    'message' + (!plugin.settings.close_tips ? ' noclose' : ''),
                        css: {
                            'width': 'auto'
                        }
                    });

                    // add the error message
                    message.html(validation_rule.message);

                    // add the message container to the main container
                    container.append(message);

                    // if a "close" button is required
                    if (plugin.settings.close_tips) {

                        // create the close button
                        var close = jQuery('<a/>', {
                            'href':    'javascript:void(0)',
                            'class':    'close' + ($.browser.msie && $.browser.version.match(/^6/) ? '-ie6' : '')
                        });

                        // all it contains is an "x"
                        close.html('x');

                        // attach the events
                        close.bind({

                            'click': function(e) {e.preventDefault(); plugin.hide_error(attributes['name'])},
                            'focus': function() {close.blur()}

                        });

                        // add the close button to the error message
                        message.append(close);

                    }

                    // create the error messages's arrow
                    var arrow = jQuery('<div/>', {
                        'class':    'arrow'
                    });

                    // add it to the error message
                    container.append(arrow);

                    // inject the error message into the DOM
                    $('body').append(container);

                    // get container's size
                    var container_size = {'x': container.outerWidth(), 'y': container.outerHeight()};

                    // get arrow's size
                    arrow_size = {'x': arrow.outerWidth(), 'y': arrow.outerHeight()};

                    // set the arrow centered horizontally
                    arrow.css('left', (container_size.x / 2) - (arrow_size.x / 2) - 1);

                    // the "left" of the container is set based on the "tips_position" property
                    var left = (plugin.settings.tips_position == 'left' ? element_position.left : element_position.right) - (container_size.x / 2);

                    // if element is a radio button or a checkbox
                    if (attributes['type'] == 'radio' || attributes['type'] == 'checkbox') {

                        // set the "left" of the container centered on the radio button/checkbox
                        left = element_position.right - (container_size.x / 2) - (element.outerWidth() / 2) + 1;

                    }

                    // if "left" is outside the visible part of the page, adjust it
                    if (left < 0) left = 2;

                    // set left now because this might lead to text wrapping
                    container.css('left', left);

                    // now get the size again
                    container_size = {'x': container.outerWidth(), 'y': container.outerHeight()};

                    // set the container's "top"
                    var top = (element_position.top - container_size.y + (arrow_size.y / 2) - 1);

                    // if "top" is outsude the visible part of the page, adjust it
                    if (top < 0) top = 2;

                    // set the final position of the container
                    container.css({
                        left:   left + 'px',
                        top:    top + 'px',
                        height: (container_size.y - (arrow_size.y / 2)) + 'px'
                    });

                    // the name to save the error block by
                    var id = (attributes['type'] == 'radio' || attributes['type'] == 'checkbox' ? attributes['name'] : attributes['id']);

                    // add the error to the error blocks array
                    error_blocks[id] = container;

                    // create an IFrame shim for the container (only in IE6)
                    _shim(container);

                    // the error message is slightly transparent
                    container.animate({
                        'opacity'   : .9
                    }, 250);

                    // if this is the first error message, and we have to scroll to the it
                    if (++counter == 1 && plugin.settings.scroll_to_error) {

                        // scroll to the element
                        $('html, body').animate({scrollTop:container.css('top').replace(/px/, '') - 10}, 250);

                        // don't check any further
                        break;

                    }

                }

            }

        }

        /**
         *  Submits the form.
         *
         *  @return void
         */
        plugin.submit = function() {

            // if there are any controls that require validation
            if (undefined != plugin.settings.error_messages)

                // fire the form's submit event manually
                $form.trigger('submit');

            // otherwise
            else

                // submit the form natively
                form.submit();

        }

        /**
         *  Checks if an element is valid or not.
         *
         *  @param  object  element     The jQuery element to check.
         *
         *  @return boolean             Returns TRUE if every rule attached to the element was obeyed, FALSE if not.
         */
        plugin.validate_control = function(element) {

            // get the ID and the type of the element
            var attributes = {'id': element.attr('id'), 'type': _type(element)};

            // by default, we assume the control validates
            var control_is_valid = true;

            // get the control's validation rules
            var control_validation_rules = validation_rules[attributes['id']];

            // if control has any validation rules attached
            if (undefined != control_validation_rules) {

                // if a rule is not passed, this variable hold the name of that rule
                var rule_not_passed = null;

                // if a rule is not passed, and it is a custom rule, this variable hold the name of that rule
                var custom_rule_name = null;

                // delete any error messages for the current control
                delete control_validation_rules.message;

                // iterate through the validation rules
                for (var rule in control_validation_rules['rules']) {

                    // if control is not valid, do not look further
                    if (!control_is_valid) break;

                    // check the rule's name
                    switch (rule) {

                        case 'alphabet':

                            // if element type is one of the following
                            switch (attributes['type']) {

                                case 'password':
                                case 'text':
                                case 'textarea':

                                    // the regular expression to use:
                                    // a-z plus additional characters (if any), case-insensitive
                                    var exp = new RegExp('^[a-z' + _escape_regexp(control_validation_rules['rules'][rule][0]).replace(/\s/, '\\s') + ']+$', 'ig');

                                    // if value is not an empty string and the regular expression is not matched, the rule doesn't validate
                                    if ($.trim(element.val()) != '' && !exp.test(element.val())) control_is_valid = false;

                                    break;

                            }

                            break;

                        case 'alphanumeric':

                            // if element type is one of the following
                            switch (attributes['type']) {

                                case 'password':
                                case 'text':
                                case 'textarea':

                                    // the regular expression to use:
                                    // a-z, 0-9 plus additional characters (if any), case-insensitive
                                    var exp = new RegExp('^[a-z0-9' + _escape_regexp(control_validation_rules['rules'][rule][0]).replace(/\s/, '\\s') + ']+$', 'ig');

                                    // if value is not an empty string and the regular expression is not matched, the rule doesn't validate
                                    if ($.trim(element.val()) != '' && !exp.test(element.val())) control_is_valid = false;

                                    break;

                            }

                            break;

                        case 'compare':

                            // if element type is one of the following
                            switch (attributes['type']) {

                                case 'password':
                                case 'text':
                                case 'textarea':

                                    // if
                                    if (

                                        // element to compare with doesn't exist OR
                                        !$('#' + control_validation_rules['rules'][rule][0]) ||

                                        (

                                            // element to compare with exists
                                            $('#' + control_validation_rules['rules'][rule][0]) &&

                                            // but it doesn't have the same value as the current element's value
                                            element.val() != $('#' + control_validation_rules['rules'][rule][0]).val()

                                        )

                                    // the rule doesn't validate
                                    ) control_is_valid = false;

                                    break;

                            }

                            break;

                        case 'custom':

                            var break_inner_loop = false;

                            // iterate through the custom functions
                            $.each(control_validation_rules['rules'][rule], function(index, arguments) {

                                // exit if we don't need to look any further
                                if (break_inner_loop) return;

                                // create an array out of "arguments" which, at this point, is a string
                                arguments = $.map(arguments.split(','), function(value) { return value.replace(/mark\;/g, ',')});

                                // the final array of arguments will contain, in order, the function's name,
                                // the element's value and any additional arguments
                                arguments = $.merge($.merge([arguments.shift()], [element.val()]), arguments);

                                // see if function is in the global namespace (member of the window object) or in jQuery's namespave
                                var fn = (typeof arguments[0] == 'function') ? arguments[0] : (typeof window[arguments[0]] == 'function' ? window[arguments[0]] : false);

                                // if custom function exists
                                if (fn !== false)

                                    // call the custom function
                                    control_is_valid = fn.apply(fn, arguments.slice(1));

                                // if custom function doesn't exist, consider that the control does not pass validation
                                else control_is_valid = false;

                                // if the rule doesn't validate, don't check the other custom functions
                                if (!control_is_valid) {

                                    // save the custom function's name
                                    // we'll need it later to retrieve the associated error message
                                    custom_rule_name = arguments[0];

                                    // don't check any other custom functions
                                    break_inner_loop = true;

                                }

                            });

                            break;

                        case 'date':

                            // if element type is one of the following
                            switch (attributes['type']) {

                                case 'text':

                                    // if element has a value
                                    if ($.trim(element.val()) != '') {

                                        // by default, we assume the date is invalid
                                        var valid_date = false;

                                        // get the required date format
                                        var format = element.data('Zebra_DatePicker').settings.format.replace(/\s/g, '');

                                        // escape characters that could have special meaning in a regular expression
                                        format = _escape_regexp(format);

                                        // allowed characters in date's format
                                        var format_chars = ['d','D','j','l','N','S','w','F','m','M','n','Y','y','G','H','g','h','a','A','i','s','U'];

                                        // this array will contain the characters defining the date's format
                                        var matches = new Array;

                                        // iterate through the allowed characters in date's format
                                        for (var i = 0; i < format_chars.length; i++) {

                                            // if character is found in the date's format
                                            if ((position = format.indexOf(format_chars[i])) > -1) {

                                                // save it, alongside the character's position
                                                matches.push({character: format_chars[i], position: position});

                                            }

                                        }

                                        // sort characters defining the date's format based on their position, ascending
                                        matches.sort(function(a, b){ return a.position - b.position });

                                        // this array will contain the regular expression built for each of the characters
                                        // used in the date's format
                                        var regexp = new Array;

                                        // iterate through the characters defining the date's format
                                        $.each(matches, function(index, match) {

                                            // add to the array of regular expressions, based on the character
                                            switch (match.character) {

                                                case 'd': regexp.push('0[1-9]|[12][0-9]|3[01]'); break;
                                                case 'D': regexp.push('[a-z]{3}'); break;
                                                case 'j': regexp.push('[1-9]|[12][0-9]|3[01]'); break;
                                                case 'l': regexp.push('[a-z]+'); break;
                                                case 'N': regexp.push('[1-7]'); break;
                                                case 'S': regexp.push('st|nd|rd|th'); break;
                                                case 'w': regexp.push('[0-6]'); break;
                                                case 'F': regexp.push('[a-z]+'); break;
                                                case 'm': regexp.push('0[1-9]|1[012]+'); break;
                                                case 'M': regexp.push('[a-z]{3}'); break;
                                                case 'n': regexp.push('[1-9]|1[012]'); break;
                                                case 'Y': regexp.push('[0-9]{4}'); break;
                                                case 'y': regexp.push('[0-9]{2}'); break;
                                                case 'G':
                                                case 'H':
                                                case 'g':
                                                case 'h': regexp.push('[0-9]{1,2}'); break;
                                                case 'a':
                                                case 'A': regexp.push('(am|pm)'); break;
                                                case 'i':
                                                case 's': regexp.push('[012345][0-9]'); break;

                                            }

                                        });

                                        // if we have an array of regular expressions
                                        if (regexp.length > 0) {

                                            // we will replace characters in the date's format in reversed order
                                            matches.reverse();

                                            // iterate through the characters in date's format
                                            $.each(matches, function(index, match) {

                                                // replace each character with the appropriate regular expression
                                                format = format.replace(match.character, '(' + regexp[regexp.length - index - 1] + ')');

                                            });

                                            // the final regular expressiom
                                            regexp = new RegExp('^' + format + '$', 'ig');

                                            // if regular expression was matched
                                            if ((segments = regexp.exec(element.val().replace(/\s/g, '')))) {

                                                // check if date is a valid date (i.e. there's no February 31)

                                                var original_day = null;
                                                var original_month = null;
                                                var original_year = null;
                                                var english_days   = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
                                                var english_months = ['January','February','March','April','May','June','July','August','September','October','November','December'];
                                                var iterable = null;

                                                // reverse back the characters in the date's format
                                                matches.reverse();

                                                // by default, we assume the date is valid
                                                var valid = true;

                                                // iterate through the characters in the date's format
                                                $.each(matches, function(index, match) {

                                                    // if the date is not valid, don't look further
                                                    if (!valid) return true;

                                                    // based on the character
                                                    switch (match.character) {

                                                        case 'm':
                                                        case 'n':

                                                            // extract the month from the value entered by the user
                                                            original_month = parseInt(segments[index + 1], 10);

                                                            break;

                                                        case 'd':
                                                        case 'j':

                                                            // extract the day from the value entered by the user
                                                            original_day = parseInt(segments[index + 1], 10);

                                                            break;

                                                        case 'D':
                                                        case 'l':
                                                        case 'F':
                                                        case 'M':

                                                            // if day is given as day name, we'll check against the names in the used language
                                                            if (match.character == 'D' || match.character == 'l') iterable = element.data('Zebra_DatePicker').settings.days;

                                                            // if month is given as month name, we'll check against the names in the used language
                                                            else iterable = element.data('Zebra_DatePicker').settings.months;

                                                            // by default, we assume the day or month was not entered correctly
                                                            valid = false;

                                                            // iterate through the month/days in the used language
                                                            $.each(iterable, function(key, value) {

                                                                // if month/day was entered correctly, don't look further
                                                                if (valid) return true;

                                                                // if month/day was entered correctly
                                                                if (segments[index + 1].toLowerCase() == value.substring(0, (match.character == 'D' || match.character == 'M' ? 3 : value.length)).toLowerCase()) {

                                                                    // extract the day/month from the value entered by the user
                                                                    switch (match.character) {

                                                                        case 'D': segments[index + 1] = english_days[key].substring(0, 3); break;
                                                                        case 'l': segments[index + 1] = english_days[key]; break;
                                                                        case 'F': segments[index + 1] = english_months[key]; original_month = key + 1; break;
                                                                        case 'M': segments[index + 1] = english_months[key].substring(0, 3); original_month = key + 1; break;

                                                                    }

                                                                    // day/month value is valid
                                                                    valid = true;

                                                                }

                                                            });

                                                            break;

                                                        case 'Y':

                                                            // extract the year from the value entered by the user
                                                            original_year = parseInt(segments[index + 1], 10);

                                                            break;

                                                        case 'y':

                                                            // extract the year from the value entered by the user
                                                            original_year = '19' + parseInt(segments[index + 1], 10);

                                                            break;

                                                    }
                                                });

                                                // if everything was ok so far
                                                if (valid) {

                                                    // generate a Date object using the values entered by the user
                                                    var date = new Date(original_year, original_month - 1, original_day);

                                                    // if, after that, the date is the same as the date entered by the user
                                                    if (date.getFullYear() == original_year && date.getDate() == original_day && date.getMonth() == (original_month - 1)) {

                                                        // set the timestamp as a property of the element
                                                        element.data('timestamp', Date.parse(english_months[original_month - 1] + ' ' + original_day + ', ' + original_year));

                                                        // date is valid
                                                        valid_date = true;

                                                    }

                                                }

                                            }

                                        }

                                        // if date is not valid, the rule doesn't validate
                                        if (!valid_date) control_is_valid = false;

                                    }

                                break;
                            }

                            break;

                        case 'datecompare':

                            // if element type is one of the following
                            switch (attributes['type']) {

                                case 'password':
                                case 'text':
                                case 'textarea':

                                    // if
                                    if (

                                        // rule is setup correctly
                                        undefined != control_validation_rules['rules'][rule][0] &&
                                        undefined != control_validation_rules['rules'][rule][1] &&

                                        // element to compare to exists
                                        $(control_validation_rules['rules'][rule][0]) &&

                                        // element to compare to has a valid date as the value
                                        plugin.validate_control($(control_validation_rules['rules'][rule][0])) === true &&

                                        // current element was validated and contains a valid date as the value
                                        undefined != element.data('timestamp')

                                    ) {

                                        // compare the two dates according to the comparison operator
                                        switch (control_validation_rules['rules'][rule][1]) {

                                            case '>':

                                                control_is_valid = (element.data('timestamp') > $('#' + control_validation_rules['rules'][rule][0]).data('timestamp'));
                                                break;

                                            case '>=':

                                                control_is_valid = (element.data('timestamp') >= $('#' + control_validation_rules['rules'][rule][0]).data('timestamp'));
                                                break;

                                            case '<':

                                                control_is_valid = (element.data('timestamp') < $('#' + control_validation_rules['rules'][rule][0]).data('timestamp'));
                                                break;

                                            case '<=':

                                                control_is_valid = (element.data('timestamp') <= $('#' + control_validation_rules['rules'][rule][0]).data('timestamp'));
                                                break;

                                        }

                                    // otherwise, there is a problem and thus, the rule does not validate
                                    } else control_is_valid = false;

                                    break;

                            }

                            break;

                        case 'digits':

                            // if element type is one of the following
                            switch (attributes['type']) {

                                case 'password':
                                case 'text':
                                case 'textarea':

                                    // the regular expression to use:
                                    // 0-9 plus additional characters (if any)
                                    var exp = new RegExp('^[0-9' + _escape_regexp(control_validation_rules['rules'][rule][0]).replace(/\s/, '\\s') + ']+$', 'ig');

                                    // if value is not an empty string and the regular expression is not matched, the rule doesn't validate
                                    if ($.trim(element.val()) != '' && !exp.test(element.val())) control_is_valid = false;

                                    break;
                            }

                            break;

                        case 'email':

                            // if element type is one of the following
                            switch (attributes['type']) {

                                case 'password':
                                case 'text':
                                case 'textarea':

                                    // if value is not an empty string and the regular expression is not matched, the rule doesn't validate
                                    if ($.trim(element.val()) != '' && null == element.val().match(/^([a-zA-Z0-9_\-\+\~\^\{\}]+[\.]?)+@{1}([a-zA-Z0-9_\-\+\~\^\{\}]+[\.]?)+\.[A-Za-z0-9]{2,}$/)) control_is_valid = false;

                                    break;
                            }

                            break;

                        case 'emails':

                            // if element type is one of the following
                            switch (attributes['type']) {

                                case 'password':
                                case 'text':
                                case 'textarea':

                                    // split addresses by commas
                                    var addresses = element.val().split(',');

                                    // iterate through the email addresses
                                    addresses.each(function(address) {

                                        // if value is not an empty string and the regular expression is not matched, the rule doesn't validate
                                        if ($.trim(address) != '' && null == $.trim(address).match(/^([a-zA-Z0-9_\-\+\~\^\{\}]+[\.]?)+@{1}([a-zA-Z0-9_\-\+\~\^\{\}]+[\.]?)+\.[A-Za-z0-9]{2,}$/)) control_is_valid = false;

                                    });

                                    break;

                            }

                            break;

                        case 'filesize':

                            // if element type is one of the following
                            switch (attributes['type']) {

                                case 'file':

                                    // see if a file was uploaded
                                    var file_info = element.data('file_info');

                                    // if a file was uploaded
                                    if (file_info) {

                                        // if
                                        if (

                                            // there's something wrong with the uploaded file
                                            undefined == file_info[2] ||
                                            undefined == file_info[3] ||

                                            // there was a specific error while uploading the file
                                            file_info[2] != 0 ||

                                            // the uploaded file's size is larger than the allowed size
                                            parseInt(file_info[3], 10) > parseInt(control_validation_rules['rules'][rule][0], 10)

                                        // the rule doesn't validate
                                        ) control_is_valid = false;

                                    }

                                    break;

                            }

                            break;

                        case 'float':

                            // if element type is one of the following
                            switch (attributes['type']) {

                                case 'password':
                                case 'text':
                                case 'textarea':

                                    // the regular expression to use:
                                    // only digits (0 to 9) and/or one dot (but not as the very first character) and/or one minus sign
                                    // (but only if it is the very first character) plus characters given as additional characters (if any).
                                    var exp = new RegExp('^[0-9\-\.' + _escape_regexp(control_validation_rules['rules'][rule][0]).replace(/\s/, '\\s') + ']+$', 'ig');

                                    // if
                                    if (

                                        // value is not an empty string
                                        $.trim(element.val()) != '' &&

                                        (

                                            // value is a minus sign
                                            $.trim(element.val()) == '-' ||

                                            // value is a dot
                                            $.trim(element.val()) == '.' ||

                                            // there are more than one minus signs
                                            (null != element.val().match(/\-/g) && element.val().match(/\-/g).length > 1) ||

                                            // there are more than one dots
                                            (null != element.val().match(/\./g) && element.val().match(/\./g).length > 1) ||

                                            // if the minus sign is not the very first character
                                            element.val().indexOf('-') > 0 ||

                                            // the regular expression is not matched
                                            !exp.test(element.val())

                                        )

                                    // the rule doesn't validate
                                    ) control_is_valid = false;

                                    break;

                            }

                            break;

                        case 'image':

                            // if element type is one of the following
                            switch (attributes['type']) {

                                case 'file':

                                    // see if a file was uploaded
                                    var file_info = element.data('file_info');

                                    // if
                                    if (

                                        // a file was uploaded
                                        file_info &&

                                        // uploaded file is not a valid image type
                                        null == file_info[1].match(/image\/(gif|jpeg|png|pjpeg)/i)

                                    // the rule doesn't validate
                                    ) control_is_valid = false;

                                    break;

                            }

                            break;

                        case 'length':

                            // if element type is one of the following
                            switch (attributes['type']) {

                                case 'password':
                                case 'text':
                                case 'textarea':

                                    // if
                                    if (

                                        // value is not an empty string
                                        $.trim(element.val()) != '' &&

                                        // lower limit is given and the length of entered value is smaller than it
                                        (undefined != control_validation_rules['rules'][rule][0] && $.trim(element.val()).length < control_validation_rules['rules'][rule][0]) ||

                                        // upper limit is given and the length of entered value is greater than it
                                        (undefined != control_validation_rules['rules'][rule][1] && control_validation_rules['rules'][rule][1] > 0 && element.val().length > control_validation_rules['rules'][rule][1])

                                    // the rule doesn't validate
                                    ) control_is_valid = false;

                                    break;

                            }

                            break;

                        case 'number':

                            // if element type is one of the following
                            switch (attributes['type']) {

                                case 'password':
                                case 'text':
                                case 'textarea':

                                    // the regular expression to use:
                                    // digits (0 to 9) and/or one minus sign (but only if it is the very first character) plus
                                    // characters given as additional characters (if any).
                                    var exp = new RegExp('^[0-9\-' + _escape_regexp(control_validation_rules['rules'][rule][0]).replace(/\s/, '\\s') + ']+$', 'ig');

                                    // if
                                    if (

                                        // value is not an empty string
                                        $.trim(element.val()) != '' &&

                                        (

                                            // value is a minus sign
                                            $.trim(element.val()) == '-' ||

                                            // there are more than one minus signs
                                            (null != element.val().match(/\-/g) && element.val().match(/\-/g).length > 1) ||

                                            // the minus sign is not the very first character
                                            element.val().indexOf('-') > 0 ||

                                            // the regular expression is not matched
                                            !exp.test(element.val())

                                        )

                                    // the rule doesn't validate
                                    ) control_is_valid = false;

                                    break;

                            }

                            break;

                        case 'regexp':

                            // if element type is one of the following
                            switch (attributes['type']) {

                                case 'password':
                                case 'text':
                                case 'textarea':

                                    // the regular expression to use
                                    var exp = new RegExp(control_validation_rules['rules'][rule][0], 'g');

                                    // if value is not an empty string and the regular expression is not matched, the rule doesn't validate
                                    if ($.trim(element.val()) != '' && null == exp.exec(element.val())) control_is_valid = false;

                                    break;

                            }

                            break;

                        case 'required':

                            // if element type is one of the following
                            switch (attributes['type']) {

                                case 'checkbox':
                                case 'radio':

                                    // by default, we assume there's nothing checked
                                    var checked = false;

                                    // iterate through the controls sharing the same name as the current element
                                    controls_groups[attributes['id']].each(function() {

                                        // if any of them is checked set a flag
                                        if (this.checked) checked = true;

                                    });

                                    // if nothing is checked, the rule doesn't validate
                                    if (!checked) control_is_valid = false;

                                    break;

                                case 'file':
                                case 'password':
                                case 'text':
                                case 'textarea':

                                    // if value is am empty string, the rule doesn't validate
                                    if ($.trim(element.val()) == '') control_is_valid = false;

                                    break;

                                case 'select-one':

                                    if (

                                        // if
                                        (

                                            // the "other" attribute is set
                                            element.hasClass('other') &&

                                            // the "other" value is set
                                            element.val() == 'other' &&

                                            // nothing is entered in the attached "other" field
                                            (!$('#' + attributes['id'] + '_other').length || $.trim($('#' + attributes['id'] + '_other').val()) == '')

                                        ) ||

                                        // nothing is selected
                                        element.get(0).selectedIndex == 0

                                    // the rule doesn't validate
                                    ) control_is_valid = false;

                                    break;

                                case 'select-multiple':

                                    // if nothing is selected, the rule doesn't validate
                                    if (element.get(0).selectedIndex == -1) control_is_valid = false;

                                    break;

                            }

                            break;

                    }

                    // if the rule didn't validate
                    if (!control_is_valid) {

                        // the name of the rule that didn't validate
                        rule_not_passed = rule;

                        // set the error message's text
                        control_validation_rules.message = plugin.settings.error_messages[attributes['id']][rule == 'custom' ? 'custom_' + custom_rule_name : rule_not_passed];

                        // save the element's value
                        control_validation_rules.value = element.val();

                    }

                }

            }

            // return TRUE if the all the rules were obeyed or the name of the rule if a rule didn't validate
            return (control_is_valid ? true : rule_not_passed);

        }

        /**
         *  Checks if form is valid or not
         *
         *  @return boolean     Returns TRUE if all the form's controls are valid or FALSE otherwise.
         */
        plugin.validate = function() {

            var control = null, id = null;

            // by default, we assume the form validates
            var form_is_valid = true;

            // iterate through all the validation rules
            for (index in validation_rules) {

                // if form is not valid, don't check any further
                if (!form_is_valid) break;

                // get the element that needs to be validated
                element = validation_rules[index]['element'];

                // get the element's ID
                id = element.attr('id');

                // if element does not validate
                if ((rule_not_passed = plugin.validate_control(element)) !== true) {

                    // the form is not valid
                    form_is_valid = false;

                    // don't check other controls
                    break;

                }

            }

            // if form validates and there's an onValid function to be run, run it
            if (form_is_valid && undefined != plugin.settings.onValid) return plugin.settings.onValid();

            // return the result of the validation
            return form_is_valid;

        }


        /**
         *  Escapes special characters in a string, preparing it for use in a regular expression.
         *
         *  @param  string  str     The string in which special characters should be escaped.
         *
         *  @return string          Returns the string with escaped special characters.
         *
         *  @access private
         */
        var _escape_regexp = function(str) {

		  return str.replace(/([-.*+?^${}()|[\]\/\\])/g, '\\$1');

        }

        /**
         *  Gets the cursor's position in a text element.
         *
         *  Used by the filter_input method.
         *
         *  @param  object  element     A DOM element
         *
         *  @return integer             Returns the cursor's position in a text or textarea element.
         *
         *  @access private
         */
        var _get_caret_position = function(element) {

            // if selectionStart function exists, return the cursor's position
            // (this is available for most browsers except IE < 9)
    		if (element.selectionStart != null) return element.selectionStart;

            // for IE < 9
    		var range = document.selection.createRange();
    		var duplicate = range.duplicate();

            // if element is a textbox, return the cursor's position
    		if (element.type == 'text') return (0 - duplicate.moveStart('character', -100000));

            // if element is a textarea
    		else {

                // do some computations...
    			var value = element.value;
    			var offset = value.length;
    			duplicate.moveToElementText(element);
    			duplicate.setEndPoint('StartToStart', range);

                // return the cursor's position
    			return offset - duplicate.text.length;

            }

        }

        /**
         *  Generates an iFrame shim in Internet Explorer 6 so that the tooltips appear above select boxes.
         *
         *  @return void
         *
         *  @access private
         */
        var _shim = function(el) {

            // this is necessary only if browser is Internet Explorer 6
    		if ($.browser.msie && $.browser.version.match(/^6/)) {

                // if an iFrame was not yet attached to the element
                if (!el.data('shim')) {

                    // get element's top and left position
                    var offset = el.offset();

                    // the iFrame has to have the element's zIndex minus 1
                    var zIndex = parseInt(el.css('zIndex'), 10) - 1;

                    // create the iFrame
                    var shim = jQuery('<iframe>', {
                        'src':                  'javascript:document.write("")',
                        'scrolling':            'no',
                        'frameborder':          0,
                        'allowtransparency':    'true',
                        'class':                'Zebra_Form_error_iFrameShim',
                        css: {
                            'zIndex':       zIndex,
                            'position':     'absolute',
                            'top':          offset.top,
                            'left':         offset.left,
                            'width':        el.outerWidth(),
                            'height':       el.outerHeight(),
                            'filter':       'progid:DXImageTransform.Microsoft.Alpha(opacity=0)',
                            'display':      'block'
                        }
                    });

                    // inject iFrame into DOM
                    $('body').append(shim);

                    // attach the shim to the element
                    el.data('shim', shim);

                }

            }

        }

        /**
         *  Shows or hides, as necessary, the "other" options for a "select" control, that has an "other" option set.
         *
         *  @param  DOM_element     element     A  <select> element having the "other" property set.
         *
         *  @return void
         *
         *  @access private
         */
        var _show_hide_other_option = function(select) {

            // reference to the "other option" text box
            // it has the ID of the select control, suffixed by "_other"
            var element = $('#' + select.attr('id') + '_other');

            // if the select control's value is "other"
            if (select.val() == 'other') {

                // show the "other option" text box
                element.css('display', 'block');

            // if the select control's value is different than "other"
            } else {

                // hide the "other option" text box
                element.css('display', 'none');

            }

        }

        /**
         *  Returns an element's type
         *
         *  @param  object  element     A jQuery element
         *
         *  @return string              Returns an element's type.
         *
         *                              Possible values are:
         *
         *                              button,
         *                              checkbox,
         *                              file,
         *                              password,
         *                              radio,
         *                              submit,
         *                              text,
         *                              select-one,
         *                              select-multiple,
         *                              textarea
         *
         *  @access private
         */
        var _type = function(element) {

            // values that may be returned by the is() function
            var types = [
                'button',
                'input:checkbox',
                'input:file',
                'input:password',
                'input:radio',
                'input:submit',
                'input:text',
                'select',
                'textarea'
            ];

            // iterate through the possible types
            for (index in types)

                // if we have an element's type
                if (element.is(types[index])) {

                    // if type is "select"
                    if (types[index] == 'select') {

                        // if the "multiple" attribute is set
                        if (element.attr('multiple')) return 'select-multiple';

                        // if the "multiple" attribute is not set
                        else return 'select-one';

                    }

                    // return the element's type, from which we remove the "input:" string
                    return types[index].replace(/input\:/, '');

                }

        }

        // fire up the plugin!
        // call the "constructor" method
        plugin.init();

    }

    $.fn.Zebra_Form = function(options) {

        return this.each(function() {
            var plugin = new $.Zebra_Form(this, options);
            $(this).data('Zebra_Form', plugin);
        });

    }

})(jQuery);